#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/kprobes.h>
#include <linux/uprobes.h>
#include <linux/init.h>
#include <linux/sched.h>
#include <linux/signal.h>
#include <linux/delay.h>
#include <asm/uaccess.h>
#include "kprobe_op.h"
struct list_node
{
    int no;
    unsigned long long o_addr;
    unsigned long long l_addr;
    size_t size;
    struct list_node *next;
};

static char *jump_name = "/home/work/code/src/table/jump_table";
static char *list_name = "/home/work/code/src/table/list_table";
static char *exe_name = "a.out";
pid_t tar_pid = 0;
pid_t tar_tid = 0;
unsigned char * ori_code, * bud_code;
unsigned long * ori_addr, * bud_addr ,* kori_addr, * kbud_addr;
unsigned long start_addr,dest_addr,offset,fun_size;
struct list_node *list;
int ori_speed = 0, bud_speed=0,list_num=0,bud_end=0,ori_end=0;
module_param(tar_pid, int, S_IRUGO);

unsigned long gp_user_va_to_pa(struct mm_struct *mm, unsigned long va)
{
    struct page *page;
    pgd_t *pgd = NULL;
    p4d_t *p4d = NULL;
    pud_t *pud = NULL;
    pmd_t *pmd = NULL;
    pte_t *pte = NULL;
    unsigned long addr = (unsigned long)va;
    unsigned long pa = 0;

    down_read(&mm->mmap_sem);
    //printk(KERN_INFO "pgd = 0x%p\n", mm->pgd);

    /* query page tables */
    if (!find_vma(mm, addr))
    {
        printk("virt_addr %08lx not available.\n", addr);
        goto out;
    }
    pgd = pgd_offset(mm, addr);
    if (pgd_none(*pgd))
    {
        printk("Not mapped in pgd.\n");
        goto out;
    }
    //printk("pgd val %lx.\n", pgd_val(*pgd));
    p4d = p4d_offset(pgd, addr);
    if (p4d_none(*p4d))
    {
        printk("Not mapped in pgd.\n");
        goto out;
    }

    //printk("p4d val %lx.\n", p4d_val(*p4d));
    pud = pud_offset(p4d, addr);
    if (pud_none(*pud))
    {
        printk("Not mapped in pud.\n");
        goto out;
    }

    //printk("pud val %lx.\n", pud_val(*pud));
    pmd = pmd_offset(pud, addr);
    if (pmd_none(*pmd))
    {
        printk("Not mapped in pmd.\n");
        goto out;
    }

    //printk("pmd val %lx.\n", pmd_val(*pmd));
    pte = pte_offset_kernel(pmd, addr);
    if (pte_none(*pte))
    {
        printk("Not mapped in pte.\n");
        goto out;
    }

    //printk("pte val %lx.\n", pte_val(*pte));
    if (!pte_present(*pte))
    {
        printk("pte not in RAM.\n");
        goto out;
    }

    pa = (pte_val(*pte) & PAGE_MASK) | (addr & ~PAGE_MASK);

    pa = phys_to_virt(pa); //把物理地址转换成虚拟地址
out:
    up_read(&mm->mmap_sem);
    return pa;
}

/*read a line , if overread , turn back*/
int read_line(char *buf, int buf_len, struct file *fp)
{
    int ret;
    int i = 0;
    mm_segment_t old_fs;

    old_fs = get_fs();
    set_fs(KERNEL_DS);
    if (fp->f_op->read != NULL)
    {
        return -1;
    }
    ret = kernel_read(fp, buf, buf_len, &(fp->f_pos));
    set_fs(old_fs);

    if (ret <= 0)
        return ret;

    while (buf[i++] != '\n' && i < ret)
        ;

    if (i < ret)
    {
        fp->f_pos += i - ret;
    }

    if (i < buf_len)
    {
        buf[i] = 0;
    }
    return i;
}

//find the new thread pid
static void find_pid(pid_t pid) {
    struct pid *pid_struct;
    struct task_struct *task,*p;

    pid_struct = find_get_pid(pid);
    if (!pid_struct) {
        return NULL;
    }

    task = pid_task(pid_struct, PIDTYPE_PID);
    if (IS_ERR(task)) {
        return NULL;
    }
    for_each_thread(task, p) {
        // 打印线程的 PID 和状态
        printk("LWP: %d, State: %ld\n", p->pid, p->state);
        tar_tid = p->pid;
    }
    return task;
}


static int pre_handler(struct kprobe *p, struct pt_regs *regs)
{
    int i,j;
    
    if(current->pid != tar_pid && current->pid != tar_tid) return 0;
    
    unsigned long *sig = current->pending.signal.sig;
    
    if(sig[0] != 0x10) return 0;
    for (i = 0; i < _NSIG_WORDS; ++i) {
        if (sig[i] != 0) { 
            for (j = 0; j < BITS_PER_LONG; ++j) {
                if (sig[i] & (1UL << j)) {
                    printk(KERN_INFO "Signal %d is pending\n", i * BITS_PER_LONG + j);
                }
            }
        }
    }
    
    struct pt_regs * reg = (struct pt_regs*)(regs->di);
    printk("%dip = %lx, flags = 0x%lx\n",current->pid, reg->ip, regs->flags);
    
    if(tar_tid == 0 || tar_tid == tar_pid){
        find_pid(tar_pid);
    }
    if(reg -> ip >= dest_addr && reg->ip <= dest_addr+fun_size){
        int num = 0;
        for(i=0;i<list_num;i++){
            if(bud_addr[i] == reg->ip-1){
                break;
            }
        }
        int result = __copy_to_user(kbud_addr[i],bud_code+i,1);
        reg->ip--;
        printk("pid:%d result:%d speed:%d\n",current->pid,result,bud_speed);
        bud_speed++;
        if(bud_speed == list_num) bud_end = 1;
        bud_speed = bud_speed % list_num;
        while(bud_speed > ori_speed){
            if(ori_end==1){
                ori_end=0;
                break;
            }
            msleep(100);
            num++;
            if(num >= 1200){
                return 1;
            } 
            printk("buddy等 num:%d\n",num);
        }
        sig[0] = 0x20000;
    }else if(reg -> ip >= start_addr + offset && reg->ip <= start_addr+ offset+fun_size){
        int num = 0;
        for(i=0;i<list_num;i++){
            if(ori_addr[i] == reg->ip-1){
                printk("yes! i:%d addr:%lx\n",i,ori_addr[i]);
                break;
            }
        }
        int result  = __copy_to_user(kori_addr[i],ori_code+i,1);
        reg->ip--;
        printk("pid:%d result:%d speed:%d code:%x ori_speed:%d bud_speed:%d\n",current->pid,result,ori_speed,ori_code[i],ori_speed,bud_speed);
        
        ori_speed++;
        if(ori_speed == list_num) ori_end = 1;
        ori_speed = ori_speed % list_num;
        while(ori_speed > bud_speed){
            if(bud_end==1){
                bud_end=0;
                break;
            } 
            msleep(100);
            num++;
            if(num >= 1200){
                return 1;
            } 
            printk("原进程等 pid:%d num:%d\n",tar_pid,num);
        }
        sig[0] = 0x20000; //sig_cont
    }
    return 0;
}

static void post_handler(struct kprobe *p, struct pt_regs *regs, unsigned long flags)
{
    //printk(KERN_INFO "post_handler: p->addr = 0x%p, flags = 0x%lx\n",
    //       p->addr, regs->flags);
    //int signal = current->pending.signal.sig[0];
    //printk(KERN_INFO "Received signal: %d\n", signal);
}


static struct kprobe kprobe_sync = {
    .symbol_name   = "do_signal",      // 要追踪的内核函数为 do_signal
    .pre_handler   = pre_handler,    // pre_handler 回调函数
    .post_handler  = post_handler,   // post_handler 回调函数
};

// static void insert_wait_point(){
//     int a = 0;
//     a++;
// }

static int __init kprobe_init(void)
{
    int ret;
    char line[64];
    struct list_node *temp = list;
    struct task_struct *task;
    struct vm_area_struct* vma_temp;
    int i=0;
    unsigned char int3 = 0xcc;
    struct file *jump_table = filp_open(jump_name,O_RDONLY, 0);
    struct file *list_table = filp_open(list_name, O_RDONLY, 0);
    if (IS_ERR(jump_table))
    {
        printk("读文件寄了\n");
        return 0;
    }
    if(tar_pid <= 0) return 0;

    read_line(line, sizeof(line), jump_table);
    sscanf(line, "%lx %lx %lx", &dest_addr, &offset, &fun_size);
    
    /*find the start_addr*/
    task = pid_task(find_get_pid(tar_pid), PIDTYPE_PID);
    send_sig(SIGSTOP, task, 0);
    vma_temp = task -> mm-> mmap;
    char tmp[50];
    char name[64];
    while(vma_temp){
        while(!vma_temp->vm_file){
            vma_temp = vma_temp -> vm_next;
        }
        strcpy(name,file_path(vma_temp->vm_file,tmp,50));
        if(strstr(name,exe_name) > 0){
            break;
        }
        vma_temp = vma_temp -> vm_next;
    }

    start_addr = vma_temp->vm_start;
    printk("start:%lx,dest:%lx,off:%lx,size:%lx\n",start_addr,dest_addr,offset,fun_size);
    /*let's read the block*/
    while (read_line(line, sizeof(line), list_table) > 0)
    {
        int no;
        unsigned long o_addr, l_addr,b_size;
        sscanf(line, "%d %lx %lx %lx",&no, &o_addr, &l_addr, &b_size);
        temp = kmalloc(sizeof(struct list_node),GFP_KERNEL);
        temp->no = no;
        temp->o_addr = o_addr;
        temp->l_addr = l_addr;
        temp->size = b_size;
        temp->next = NULL;
        printk("%d %lx %lx %lx\n",temp->no, temp->o_addr, temp->l_addr, temp->size);
        if (list == NULL) {
        list = temp;
        } else {
            struct list_node *cur = list;
            while (cur->next != NULL) {
                cur = cur->next;
            }
            cur->next = temp;
        }
        list_num++;
    }
    temp = list;
    ori_code = kmalloc(sizeof(char)*list_num,GFP_KERNEL);
    bud_code = kmalloc(sizeof(char)*list_num,GFP_KERNEL);
    ori_addr = kmalloc(sizeof(unsigned long)*list_num,GFP_KERNEL);
    bud_addr = kmalloc(sizeof(unsigned long)*list_num,GFP_KERNEL);
    kori_addr = kmalloc(sizeof(unsigned long)*list_num,GFP_KERNEL);
    kbud_addr = kmalloc(sizeof(unsigned long)*list_num,GFP_KERNEL);
    //准备用copy_to_user() cpoy_from_user()读写函数头部
    while(temp != NULL){
        int result;
        ori_addr[temp->no-1] = start_addr+temp->o_addr;
        bud_addr[i] = temp->l_addr - list->l_addr + dest_addr;
        kori_addr[temp->no-1] = gp_user_va_to_pa(task->mm,ori_addr[temp->no-1]);
        kbud_addr[i] = gp_user_va_to_pa(task->mm,bud_addr[i]);
        if ( access_ok(ori_addr[temp->no-1],1) ) {
            // 可以读取 addr 处的数据
            printk("能读\n");
        }
        __copy_from_user(ori_code+temp->no-1,kori_addr[temp->no-1],1);
        __copy_from_user(bud_code+i,kbud_addr[i],1);
        
        result =__copy_to_user(kori_addr[temp->no-1],&int3,1);
        if(result > 0)
        {
            printk("copy_to_user failed\n");
            return 0;
        }
        result =__copy_to_user(kbud_addr[i],&int3,1);
        if(result > 0)
        {
            printk("copy_to_user failed\n");
            return 0;
        }
        i++;
        temp = temp->next;
    }
    i=0;

    ret = register_kprobe(&kprobe_sync); // 调用 register_kprobe 注册追踪点
    if (ret < 0) {
        printk(KERN_INFO "register_kprobe failed, returned %d\n", ret);
        return ret;
    }

    send_sig(SIGCONT, task, 0);
    return 0;
}

static void __exit kprobe_exit(void)
{
    unregister_kprobe(&kprobe_sync); // 调用 unregister_kprobe 注销追踪点
    //printk(KERN_INFO "kprobe at %p unregistered\n", kp.addr);
    kfree(ori_addr);
    kfree(ori_code);
    kfree(bud_addr);
    kfree(bud_code);
    kfree(kori_addr);
    kfree(kbud_addr);
    struct list_node *cur = list;
    struct list_node *next;
    while (cur != NULL) {
        next = cur->next;
        kfree(cur);
        cur = next;
    }
    list = NULL; 
}

module_init(kprobe_init) // 注册模块初始化函数
module_exit(kprobe_exit) // 注册模块退出函数
MODULE_LICENSE("GPL");
